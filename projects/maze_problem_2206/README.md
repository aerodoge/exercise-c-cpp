# 迷宫生成与遍历程序 (C++20)

基于现代C++20标准实现的迷宫生成与求解程序，支持自动生成随机迷宫、多种求解算法和实时可视化。

## 项目概述

本项目实现了一个完整的迷宫系统，包括：
- **迷宫生成器**: 使用递归回溯算法自动生成12×12随机迷宫
- **迷宫求解器**: 使用递归算法（右手法则/DFS）寻找从起点到终点的路径
- **实时可视化**: 动画演示生成和遍历过程

## 功能特性

### 1. 现代C++20特性应用

- **Concepts（概念）**: 使用类型约束定义坐标类型
- **三路比较运算符**: `operator<=>`自动生成比较操作
- **constexpr**: 编译期常量计算
- **[[nodiscard]]**: 函数返回值检查
- **模板类**: 支持任意大小的迷宫
- **Chrono Literals**: 时间字面量 (300ms, 1s等)

### 2. 迷宫生成算法

#### 递归回溯法 (Recursive Backtracking)
本项目使用递归回溯算法生成迷宫，该算法保证生成的迷宫具有以下特性：

**算法步骤**：
1. 从起点 (1,1) 开始，将其标记为通道
2. 随机选择一个未访问的相邻单元格（跳2格，保持墙的间隔）
3. 打通当前单元格和目标单元格之间的墙
4. 递归访问新单元格
5. 当无路可走时，回溯到上一个单元格
6. 重复直到所有可达位置都被访问

**如何保证迷宫一定有解**：

这是本项目的核心创新点，通过以下三重保障机制确保生成的迷宫100%可解：

1. **连通性保证**（算法特性）
   - 递归回溯算法生成的是**完美迷宫**（Perfect Maze）
   - 从起点出发的所有通道都是连通的，形成一棵**生成树**
   - 起点可以到达所有被标记为通道的位置

2. **出口智能放置**（BFS可达性检测）
   ```cpp
   // 1. 使用BFS从起点搜索所有可达位置
   auto reachable = findReachablePositions(start);

   // 2. 找到可达区域中最右侧的列
   int maxCol = 找到所有可达位置的最大列号;

   // 3. 在最右侧列随机选择一个可达位置
   Position exitInside = 随机选择(最右列的可达位置);

   // 4. 在它的右侧（相邻格子）设置出口
   exit = {exitInside.row, exitInside.col + 1};
   ```
   - 出口位置一定在某个可达位置的**正右侧相邻格**
   - 从可达位置向右走一步就能到达出口
   - **数学保证**：如果A可达且B在A右侧相邻，则A→B可达

3. **边界控制**（防止越界和孤岛）
   - 限制通道生成范围在 `(1, N-2)` 之间，不在边界上生成
   - 确保出口不会越界（col < N）
   - 打通出口位置为通道（`grid_[exit] = '.'`）

**算法特性**：
- ✓ 唯一路径：任意两点间只有一条通路（无环）
- ✓ 完全连通：起点可达所有生成的通道
- ✓ 100%有解：出口在可达区域的相邻位置
- ✓ 复杂度高：路径曲折，具有挑战性
- ✓ 生成速度快：O(N²) 时间复杂度

### 3. 求解算法

#### 右手法则 (Right-Hand Rule)
- 遵循"永远靠着右侧墙壁行走"的策略
- 优先级：右转 > 直行 > 左转 > 后退
- 保证能找到出口（如果存在）

#### 深度优先搜索 (DFS)
- 按照上、右、下、左的顺序探索
- 回溯算法实现
- 标准的图遍历算法

### 4. 可视化功能

- 实时显示迷宫状态
- 动画展示遍历过程
- 路径标记和回溯显示
- 步数统计

## 项目结构

```
maze_problem_2206/
├── CMakeLists.txt          # CMake构建配置
├── main.cpp                # 主程序入口
├── include/                # 头文件目录
│   ├── position.hpp        # 位置和方向定义
│   ├── maze.hpp            # 迷宫求解器类声明
│   └── maze_generator.hpp # 迷宫生成器类声明与实现
└── src/                    # 实现文件目录
    └── maze.tpp            # 迷宫求解器模板实现
```

### 文件说明

| 文件 | 说明 |
|------|------|
| `include/position.hpp` | 定义Position结构体、Direction枚举和Coordinate概念 |
| `include/maze.hpp` | Maze模板类的声明和公有接口（求解器） |
| `include/maze_generator.hpp` | MazeGenerator模板类（生成器），包含完整实现 |
| `src/maze.tpp` | Maze模板类的实现（.tpp用于模板实现） |
| `main.cpp` | 程序入口，包含迷宫选择、生成和求解流程 |
| `CMakeLists.txt` | 构建配置，设置C++20标准和头文件路径 |

## 编译与运行

### 系统要求

- CMake 3.20 或更高版本
- 支持C++20的编译器（GCC 10+, Clang 10+, MSVC 19.29+）

### 编译步骤

```bash
# 配置项目
cmake -B build -S .

# 编译
cmake --build build

# 运行
./build/maze_problem_2206
```

### 使用说明

1. 运行程序后，首先选择迷宫来源：
   - 输入 `1` 使用预定义迷宫（原有示例迷宫）
   - 输入 `2` 自动生成随机迷宫（每次不同）

2. 选择求解算法：
   - 输入 `1` 使用右手法则
   - 输入 `2` 使用深度优先搜索

3. 观察迷宫遍历动画

4. 程序会显示最终结果和总步数

**示例运行**：
```bash
./build/maze_problem_2206

# 输入: 2 (生成随机迷宫)
# 输入: 2 (使用DFS求解)
# 输出: 成功找到出口！总步数: 45
```

## 迷宫图例

| 符号 | 含义 |
|------|------|
| `#` | 墙壁（不可通行） |
| `.` | 可行路径 |
| `S` | 起点 |
| `E` | 终点 |
| `X` | 正在探索的路径 |
| `o` | 已回溯的路径 |

## 示例迷宫

```
  0 1 2 3 4 5 6 7 8 9 10 11
0 # # # # # # # # # # #  #
1 # . . . # . . . . . .  #
2 # . # . # . # # # # .  #
3 # # # . # . . . . # .  #
4 # . . . . # # # . # .  E  <- 出口
5 # # # # . # . # . # .  #
6 # . . # . # . # . # .  #
7 # # . # . # . # . # .  #
8 # . . . . . . . . # .  #
9 # # # # # # . # # # .  #
10 # . . . . . . # . . .  #
11 # # # # # # # # # # #  #
```

## 代码特点

### 1. 类型安全
使用C++20 Concepts确保类型正确性：
```cpp
template<typename T>
concept Coordinate = requires(T t) {
    { t.row } -> std::convertible_to<int>;
    { t.col } -> std::convertible_to<int>;
};
```

### 2. 性能优化
- 使用 `std::array` 替代原始数组
- `constexpr` 编译期计算
- `noexcept` 标记无异常函数
- 移动语义优化

### 3. 代码可读性
- 清晰的命名规范
- 详细的注释说明
- 模块化设计
- 职责明确分离

## 算法复杂度

### 迷宫生成
- **时间复杂度**: O(N²)，其中N为迷宫边长
- **空间复杂度**: O(N²)，递归调用栈和visited数组

### 迷宫求解
- **时间复杂度**: O(N²)，最坏情况需要遍历所有格子
- **空间复杂度**: O(N²)，递归调用栈最坏情况

## 扩展建议

- [x] ~~添加迷宫自动生成功能~~ (已完成)
- [x] ~~保证生成的迷宫一定有解~~ (已完成)
- [ ] 添加广度优先搜索(BFS)算法
- [ ] 实现A*寻路算法
- [ ] 支持自定义迷宫输入
- [ ] 添加最短路径统计
- [ ] 支持多出口迷宫
- [ ] 导出路径为图像文件
- [ ] 添加Prim算法生成迷宫
- [ ] 支持不同迷宫尺寸选择

## 核心算法流程

### 迷宫生成与出口放置流程

```
开始
  ↓
初始化12×12全墙网格
  ↓
设置起点(1,1)为通道
  ↓
递归回溯生成迷宫
  │
  ├─→ 随机选择未访问方向
  ├─→ 打通墙壁，标记为通道
  ├─→ 递归访问新位置
  └─→ 无路可走时回溯
  ↓
确保边界为墙
  ↓
【关键：智能出口放置】
  ↓
使用BFS从起点搜索所有可达位置
  ↓
找到可达区域的最右侧列(maxCol)
  ↓
在maxCol列随机选择一个可达位置
  ↓
在该位置的右侧相邻格(col+1)设置出口
  ↓
打通出口位置为通道
  ↓
返回迷宫网格
  ↓
【保证】起点 → 最右列 → 出口(相邻) 100%可达
```

### 为什么100%有解？

**数学证明**：
1. 递归回溯生成的是**连通树结构**：从起点能到达所有通道
2. BFS找到的是**真实可达位置**：这些位置从起点必然可达
3. 出口在可达位置的**相邻格**：距离=1，一步可达
4. **传递性**：起点→可达位置（✓） + 可达位置→出口（✓） = 起点→出口（✓）

**测试验证**：
```bash
# 连续测试10次，100%成功
测试1: 成功找到出口！总步数: 44
测试2: 成功找到出口！总步数: 45
测试3: 成功找到出口！总步数: 49
...
```

## 技术亮点

1. **自动迷宫生成**: 使用递归回溯算法生成完美迷宫
2. **100%有解保证**: 通过BFS可达性检测和智能出口放置确保迷宫必然可解
3. **模板元编程**: 支持编译期指定迷宫大小
4. **递归算法**: 优雅实现回溯搜索
5. **实时可视化**: 动画展示算法执行过程
6. **现代C++20**: 充分利用Concepts、三路比较、constexpr等新特性

## 参考资料

- 项目来源：《跟我一起学编程系列课程：第二篇C语言项目实战》
- 项目编号：项目8 - 迷宫遍历
- C++20标准文档：[cppreference.com](https://en.cppreference.com/)

## 许可证

本项目仅用于学习和教育目的。

---

**作者备注**: 本项目展示了如何使用现代C++20特性构建清晰、高效、可维护的代码，并通过图论和算法知识保证了迷宫生成的可解性。核心创新在于使用BFS可达性检测来智能放置出口，确保100%有解。
