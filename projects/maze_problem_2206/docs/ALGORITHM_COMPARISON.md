# 迷宫求解算法对比：右手法则 vs 深度优先搜索

## 概述

本文档详细分析了迷宫求解中两种常用算法的实现差异：右手法则（Right-Hand Rule）和深度优先搜索（DFS）。

## 核心区别

### 1. 方向选择策略

#### 右手法则（Wall Follower）

**实现位置**: `src/maze.tpp:74-122`

**核心特征**:

- **动态方向决策**：需要维护当前朝向（facing direction）
- **相对方向优先级**：右转 > 直行 > 左转 > 后退
- **模拟真实行为**：贴着右侧墙壁行走

**代码实现**:

```cpp
bool traverse_right_hand(Position current, Direction facing)
{
    // 根据当前朝向动态计算相对方向
    std::array<Direction, 4> tryOrder = {{
        static_cast<Direction>((static_cast<int>(facing) + 1) % 4), // 右转
        facing,                                                      // 直行
        static_cast<Direction>((static_cast<int>(facing) + 3) % 4), // 左转
        static_cast<Direction>((static_cast<int>(facing) + 2) % 4)  // 后退
    }};

    for (Direction dir : tryOrder) {
        Position next = {current.row + _directions[static_cast<int>(dir)].row,
                         current.col + _directions[static_cast<int>(dir)].col};
        if (can_visit(next)) {
            if (traverse_right_hand(next, dir)) {  // 传递新方向
                return true;
            }
        }
    }
    // 回溯...
}
```

**关键参数**:

- `Position current`: 当前位置
- `Direction facing`: **当前朝向**（影响下一步的方向选择）

#### 深度优先搜索（DFS）

**实现位置**: `src/maze.tpp:124-163`

**核心特征**:

- **固定方向顺序**：始终按照 UP → RIGHT → DOWN → LEFT
- **绝对方向优先级**：不考虑来时方向
- **标准图遍历**：经典的深度优先搜索算法

**代码实现**:

```cpp
bool traverse_dfs(Position current)
{
    // 固定顺序遍历四个方向（上、右、下、左）
    for (const auto& dir : _directions) {
        Position next = {current.row + dir.row, current.col + dir.col};

        if (can_visit(next)) {
            if (traverse_dfs(next)) {  // 不需要传递方向
                return true;
            }
        }
    }
    // 回溯...
}
```

**关键参数**:

- `Position current`: 当前位置（仅此一个参数）

### 2. 决策逻辑对比

假设当前在某个位置，面朝**东（RIGHT）**方向：

```
        北(UP)
          ↑
    西 ←  ●  → 东(RIGHT)
          ↓
        南(DOWN)
```

**右手法则的决策顺序**:

1. 右转 → 南(DOWN)   // 相对当前朝向的右侧
2. 直行 → 东(RIGHT)  // 保持原方向
3. 左转 → 北(UP)     // 相对当前朝向的左侧
4. 后退 → 西(LEFT)   // 180度转向

**DFS的决策顺序**（无论朝向）:

1. 北(UP)     // 固定优先级第1
2. 东(RIGHT)  // 固定优先级第2
3. 南(DOWN)   // 固定优先级第3
4. 西(LEFT)   // 固定优先级第4

### 3. 探索路径特性

| 特性        | 右手法则               | 深度优先搜索         |
|-----------|--------------------|----------------|
| **路径依赖性** | 取决于初始朝向（本项目为RIGHT） | 仅取决于固定方向优先级    |
| **探索模式**  | 沿右侧边界探索，可能绕圈       | 系统化探索，倾向上、右方向  |
| **直观性**   | 模拟人类走迷宫行为          | 机器算法，不模拟现实     |
| **路径长度**  | 通常较长，可能有冗余         | 取决于方向优先级，不保证最短 |

### 4. 初始化差异

在 `solve()` 方法中（src/maze.tpp:167-201）：

```cpp
bool result;
if (useRightHand) {
    // 右手法则需要指定初始朝向
    result = traverse_right_hand(_start, Direction::RIGHT);
} else {
    // DFS不需要初始方向
    result = traverse_dfs(_start);
}
```

### 5. 算法复杂度

| 算法       | 时间复杂度 | 空间复杂度 | 备注               |
|----------|-------|-------|------------------|
| **右手法则** | O(N²) | O(N²) | 可能访问同一位置多次（不同朝向） |
| **DFS**  | O(N²) | O(N²) | 每个位置最多访问一次       |

两者都使用递归回溯，空间复杂度主要来自递归调用栈。

## 适用场景对比

### 右手法则

**优势**:

- ✅ 模拟真实走迷宫行为，直观易理解
- ✅ 实现简单，符合人类直觉
- ✅ 对简单连通迷宫（无环）保证能找到出口
- ✅ 适合教学演示

**劣势**:

- ❌ 可能走很多冗余路径
- ❌ 对复杂迷宫（有环、孤岛）可能陷入死循环
- ❌ 步数通常较多
- ❌ 需要维护方向状态，代码稍复杂

**最佳应用**:

- 简单连通迷宫（本项目生成的完美迷宫）
- 教育演示
- 机器人导航（有物理朝向的场景）

### 深度优先搜索

**优势**:

- ✅ 理论上保证找到解（如果存在）
- ✅ 代码简洁，无需维护方向状态
- ✅ 系统化探索，不会遗漏
- ✅ 标准算法，易于扩展（如添加剪枝）

**劣势**:

- ❌ 不模拟真实行为，缺乏直观性
- ❌ 可能先探索远离目标的方向
- ❌ 找到的路径不一定是最短的

**最佳应用**:

- 复杂迷宫求解
- 需要保证找到解的场景
- 作为其他算法（如A*）的基础
- 图论相关问题

## 实际运行对比

### 预期行为差异

对于本项目的12×12迷宫：

**右手法则**:

- 从起点(1,1)开始，初始朝向RIGHT
- 倾向于沿迷宫右侧边界探索
- 可能先探索南侧和东侧
- 步数通常在 40-60 步

**DFS**:

- 从起点(1,1)开始，无初始朝向
- 倾向于先向上、向右探索
- 系统化覆盖可达区域
- 步数通常在 35-55 步

### 测试建议

```bash
# 多次运行对比
./build/maze_problem_2206

# 建议测试：
# 1. 相同迷宫，不同算法 → 观察路径和步数差异
# 2. 多个随机迷宫，同一算法 → 观察算法稳定性
# 3. 记录统计数据 → 分析平均步数、回溯次数
```

## 共同点

尽管有上述差异，两种算法在本项目中有共同的实现特性：

1. **回溯机制**: 都使用递归回溯（标记为'o'）
2. **访问标记**: 都会标记已访问路径（'X'）
3. **可视化**: 都有实时动画显示
4. **终止条件**: 都在到达终点或无路可走时终止
5. **时间复杂度**: 最坏情况都是O(N²)

## 选择建议

### 选择右手法则，如果你需要:

- 模拟真实走迷宫体验
- 教学演示算法原理
- 简单连通迷宫（本项目场景）
- 强调直观性而非效率

### 选择DFS，如果你需要:

- 保证找到解（复杂迷宫）
- 代码简洁性
- 作为更复杂算法的基础
- 系统化的探索策略

## 扩展思考

### 如果要找最短路径？

两种算法都**不保证**找到最短路径，建议使用：

- **BFS（广度优先搜索）**: 保证找到最短路径
- **A\*算法**: 启发式搜索，效率更高

### 如果迷宫有环？

- **右手法则**: 可能陷入死循环（除非添加visited标记）
- **DFS**: 通过visited标记避免重复访问，可以处理

### 性能优化建议

```cpp
// 可以添加visited集合避免重复访问
std::unordered_set<Position> visited;

// 可以添加启发式函数引导搜索
int heuristic(Position current, Position target) {
    return std::abs(current.row - target.row) +
           std::abs(current.col - target.col);
}
```

## 参考代码位置

- 右手法则实现: `src/maze.tpp:74-122`
- DFS实现: `src/maze.tpp:124-163`
- 算法选择: `src/maze.tpp:167-201`
- 方向定义: `include/maze.hpp:19-25`
- Position结构: `include/position.hpp`

## 总结

**右手法则**强调**方向依赖**的探索策略，模拟真实行为，适合简单场景。

**深度优先搜索**强调**系统化**的探索策略，代码简洁，适合复杂场景。

对于本项目生成的完美迷宫（无环、单一通路），两种算法都能有效求解，选择取决于你更看重**直观性**还是**简洁性**。
