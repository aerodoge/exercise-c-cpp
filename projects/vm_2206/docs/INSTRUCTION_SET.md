# 虚拟机指令集手册

## 指令格式

所有指令采用**四位十进制数**格式：`±XXYY`

- `XX`: 操作码 (OpCode)
- `YY`: 操作数 (Operand)，通常是内存地址 (0-99)

### 示例

```
+1007  →  READ 指令，操作数 = 07
+2020  →  LOAD 指令，操作数 = 20
+3008  →  ADD 指令，操作数 = 08
```

## 指令分类

### 1. I/O 指令 (10-11)

#### READ (10) - 读取输入

**格式**: `+10XX`

**功能**: 从标准输入读取一个整数，存储到内存地址 `XX`

**示例**:

```
+1007  // 从终端读取 → 内存[7]
```

**执行流程**:

1. 提示用户输入
2. 读取整数值
3. 存储到 `memory[operand]`

**伪代码**:

```
memory[operand] = input()
```

---

#### WRITE (11) - 输出数据

**格式**: `+11XX`

**功能**: 将内存地址 `XX` 的值输出到标准输出

**示例**:

```
+1109  // 内存[9] → 终端输出
```

**执行流程**:

1. 读取 `memory[operand]`
2. 输出到终端

**伪代码**:

```
print(memory[operand])
```

---

### 2. 加载/存储指令 (20-21)

#### LOAD (20) - 加载到累加器

**格式**: `+20XX`

**功能**: 将内存地址 `XX` 的值加载到累加器

**示例**:

```
+2007  // 内存[7] → 累加器
```

**执行流程**:

1. 读取 `memory[operand]`
2. 存储到累加器

**伪代码**:

```
accumulator = memory[operand]
```

---

#### STORE (21) - 存储累加器

**格式**: `+21XX`

**功能**: 将累加器的值存储到内存地址 `XX`

**示例**:

```
+2109  // 累加器 → 内存[9]
```

**执行流程**:

1. 读取累加器的值
2. 存储到 `memory[operand]`

**伪代码**:

```
memory[operand] = accumulator
```

---

### 3. 算术运算指令 (30-33)

所有算术指令的通用流程：

1. 从 `memory[operand]` 读取操作数
2. 与累加器进行运算
3. 结果存回累加器

#### ADD (30) - 加法

**格式**: `+30XX`

**功能**: 累加器 += 内存[XX]

**示例**:

```
+3008  // accumulator += memory[8]
```

**伪代码**:

```
accumulator = accumulator + memory[operand]
```

---

#### SUBTRACT (31) - 减法

**格式**: `+31XX`

**功能**: 累加器 -= 内存[XX]

**示例**:

```
+3110  // accumulator -= memory[10]
```

**伪代码**:

```
accumulator = accumulator - memory[operand]
```

---

#### DIVIDE (32) - 除法

**格式**: `+32XX`

**功能**: 累加器 /= 内存[XX]

**示例**:

```
+3205  // accumulator /= memory[5]
```

**注意**:

- 整数除法（向下取整）
- 除数为零会抛出异常并停机

**伪代码**:

```
if memory[operand] == 0:
    throw "除数为零"
accumulator = accumulator / memory[operand]
```

---

#### MULTIPLY (33) - 乘法

**格式**: `+33XX`

**功能**: 累加器 *= 内存[XX]

**示例**:

```
+3321  // accumulator *= memory[21]
```

**伪代码**:

```
accumulator = accumulator * memory[operand]
```

---

### 4. 控制流指令 (40-43)

#### BRANCH (40) - 无条件跳转

**格式**: `+40XX`

**功能**: 无条件跳转到内存地址 `XX`

**示例**:

```
+4010  // 跳转到地址 10
```

**执行流程**:

1. 设置 `instructionCounter = operand`
2. 下一条执行 `memory[operand]` 的指令

**伪代码**:

```
PC = operand
```

---

#### BRANCHNEG (41) - 负数条件跳转

**格式**: `+41XX`

**功能**: 如果累加器 < 0，跳转到地址 `XX`；否则继续

**示例**:

```
+4107  // if (accumulator < 0) goto 07
```

**执行流程**:

1. 检查 `accumulator < 0`
2. 是：`PC = operand`
3. 否：`PC++`

**伪代码**:

```
if accumulator < 0:
    PC = operand
else:
    PC = PC + 1
```

**应用场景**: 比较大小、条件判断

---

#### BRANCHZERO (42) - 零条件跳转

**格式**: `+42XX`

**功能**: 如果累加器 == 0，跳转到地址 `XX`；否则继续

**示例**:

```
+4215  // if (accumulator == 0) goto 15
```

**执行流程**:

1. 检查 `accumulator == 0`
2. 是：`PC = operand`
3. 否：`PC++`

**伪代码**:

```
if accumulator == 0:
    PC = operand
else:
    PC = PC + 1
```

**应用场景**: 循环计数、相等判断

---

#### HALT (43) - 停机

**格式**: `+4300`

**功能**: 停止虚拟机运行

**示例**:

```
+4300  // 停机
```

**执行流程**:

1. 设置 `running = false`
2. 打印 "程序执行完毕"
3. 退出执行循环

**伪代码**:

```
running = false
print("程序执行完毕")
```

---

## 完整示例程序

### 示例 1: 计算两数之和

```
地址  指令    说明
00   +1007   READ 07     // 读取 A → 内存[7]
01   +1008   READ 08     // 读取 B → 内存[8]
02   +2007   LOAD 07     // 内存[7] → 累加器
03   +3008   ADD 08      // 累加器 += 内存[8]
04   +2109   STORE 09    // 累加器 → 内存[9]
05   +1109   WRITE 09    // 输出内存[9]
06   +4300   HALT        // 停机
```

**执行过程** (假设输入 10 和 20)：

| 步骤 | PC | 指令    | 操作       | 累加器 | 内存[7] | 内存[8] | 内存[9] |
|----|----|-------|----------|-----|-------|-------|-------|
| 1  | 0  | +1007 | READ 07  | 0   | 10    | 0     | 0     |
| 2  | 1  | +1008 | READ 08  | 0   | 10    | 20    | 0     |
| 3  | 2  | +2007 | LOAD 07  | 10  | 10    | 20    | 0     |
| 4  | 3  | +3008 | ADD 08   | 30  | 10    | 20    | 0     |
| 5  | 4  | +2109 | STORE 09 | 30  | 10    | 20    | 30    |
| 6  | 5  | +1109 | WRITE 09 | 30  | 10    | 20    | 30    |
| 7  | 6  | +4300 | HALT     | 30  | 10    | 20    | 30    |

**输出**: `30`

---

### 示例 2: 找出两数中的较大者

```
地址  指令    说明
00   +1009   READ 09        // 读取 A
01   +1010   READ 10        // 读取 B
02   +2009   LOAD 09        // A → 累加器
03   +3110   SUBTRACT 10    // 累加器 -= B
04   +4107   BRANCHNEG 07   // 如果 < 0，跳到 07
05   +1109   WRITE 09       // 输出 A (A 较大)
06   +4300   HALT
07   +1110   WRITE 10       // 输出 B (B 较大)
08   +4300   HALT
```

**执行过程** (假设输入 15 和 20)：

| 步骤 | PC | 指令    | 操作           | 累加器 | 内存[9] | 内存[10] |
|----|----|-------|--------------|-----|-------|--------|
| 1  | 0  | +1009 | READ 09      | 0   | 15    | 0      |
| 2  | 1  | +1010 | READ 10      | 0   | 15    | 20     |
| 3  | 2  | +2009 | LOAD 09      | 15  | 15    | 20     |
| 4  | 3  | +3110 | SUBTRACT 10  | -5  | 15    | 20     |
| 5  | 4  | +4107 | BRANCHNEG 07 | -5  | 15    | 20     |
| 6  | 7  | +1110 | WRITE 10     | -5  | 15    | 20     |
| 7  | 8  | +4300 | HALT         | -5  | 15    | 20     |

**输出**: `20` (较大的数)

---

### 示例 3: 计算乘积

```
地址  指令    说明
00   +1020   READ 20     // 读取 A
01   +1021   READ 21     // 读取 B
02   +2020   LOAD 20     // A → 累加器
03   +3321   MULTIPLY 21 // 累加器 *= B
04   +2122   STORE 22    // 结果 → 内存[22]
05   +1122   WRITE 22    // 输出结果
06   +4300   HALT
```

**执行过程** (假设输入 6 和 7)：

| 步骤 | PC | 指令    | 操作          | 累加器 | 内存[20] | 内存[21] | 内存[22] |
|----|----|-------|-------------|-----|--------|--------|--------|
| 1  | 0  | +1020 | READ 20     | 0   | 6      | 0      | 0      |
| 2  | 1  | +1021 | READ 21     | 0   | 6      | 7      | 0      |
| 3  | 2  | +2020 | LOAD 20     | 6   | 6      | 7      | 0      |
| 4  | 3  | +3321 | MULTIPLY 21 | 42  | 6      | 7      | 0      |
| 5  | 4  | +2122 | STORE 22    | 42  | 6      | 7      | 42     |
| 6  | 5  | +1122 | WRITE 22    | 42  | 6      | 7      | 42     |
| 7  | 6  | +4300 | HALT        | 42  | 6      | 7      | 42     |

**输出**: `42`

---

## 指令快速参考

| 操作码 | 指令         | 格式    | 功能            | 影响累加器 | 改变PC |
|-----|------------|-------|---------------|-------|------|
| 10  | READ       | +10XX | 终端 → 内存[XX]   | ✗     | ✗    |
| 11  | WRITE      | +11XX | 内存[XX] → 终端   | ✗     | ✗    |
| 20  | LOAD       | +20XX | 内存[XX] → 累加器  | ✓     | ✗    |
| 21  | STORE      | +21XX | 累加器 → 内存[XX]  | ✗     | ✗    |
| 30  | ADD        | +30XX | 累加器 += 内存[XX] | ✓     | ✗    |
| 31  | SUBTRACT   | +31XX | 累加器 -= 内存[XX] | ✓     | ✗    |
| 32  | DIVIDE     | +32XX | 累加器 /= 内存[XX] | ✓     | ✗    |
| 33  | MULTIPLY   | +33XX | 累加器 *= 内存[XX] | ✓     | ✗    |
| 40  | BRANCH     | +40XX | 跳转到 XX        | ✗     | ✓    |
| 41  | BRANCHNEG  | +41XX | 如果 累加器<0 跳转   | ✗     | ✓    |
| 42  | BRANCHZERO | +42XX | 如果 累加器==0 跳转  | ✗     | ✓    |
| 43  | HALT       | +4300 | 停机            | ✗     | ✓    |

---

## 编程技巧

### 1. 数据存储约定

建议将程序和数据分开存储：

- **0-49**: 程序指令区
- **50-99**: 数据区

### 2. 实现条件判断

**判断 A > B**:

```
LOAD A
SUBTRACT B
BRANCHNEG label_false    // 如果 A-B < 0，即 A < B
// A >= B 的代码
BRANCH end
label_false:
// A < B 的代码
end:
```

### 3. 实现循环

**计数循环**:

```
LOAD counter
BRANCHZERO end           // 如果计数器为 0，退出
// 循环体
LOAD counter
SUBTRACT one
STORE counter
BRANCH loop_start
end:
```

### 4. 变量命名约定

虽然虚拟机使用数字地址，建议在注释中使用变量名：

```
+1050   // READ A      (内存[50] 作为变量 A)
+1051   // READ B      (内存[51] 作为变量 B)
+2050   // LOAD A
+3051   // ADD B
```

---

## 常见错误

### 1. 除数为零

```
+1050   // READ divisor
+2051   // LOAD dividend
+3250   // DIVIDE divisor   ← 如果 memory[50] == 0，会抛出异常
```

**解决方案**: 使用前检查

### 2. 地址越界

```
+10100  // ← 错误！操作数 100 超出内存范围 (0-99)
```

### 3. 无限循环

```
00  +4000  // BRANCH 00  ← 无限跳转到自己
```

### 4. 忘记 HALT

程序末尾必须有 HALT，否则会执行到内存末尾的未定义数据。

---

## 附录：操作码映射表

| 十进制 | 二进制      | 指令         |
|-----|----------|------------|
| 10  | 00001010 | READ       |
| 11  | 00001011 | WRITE      |
| 20  | 00010100 | LOAD       |
| 21  | 00010101 | STORE      |
| 30  | 00011110 | ADD        |
| 31  | 00011111 | SUBTRACT   |
| 32  | 00100000 | DIVIDE     |
| 33  | 00100001 | MULTIPLY   |
| 40  | 00101000 | BRANCH     |
| 41  | 00101001 | BRANCHNEG  |
| 42  | 00101010 | BRANCHZERO |
| 43  | 00101011 | HALT       |
