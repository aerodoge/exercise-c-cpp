# 8皇后问题求解器

## 项目简介

这是一个使用C++20实现的8皇后问题求解器。该程序使用经典的回溯算法，能够找到8皇后问题的所有92个解。

## 问题描述

8皇后问题是一个经典的回溯算法问题：在8×8的国际象棋棋盘上放置8个皇后，使得任意两个皇后都不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一对角线上。

## 算法实现

### 核心算法：回溯法（Backtracking）

程序采用回溯算法逐行放置皇后：
1. 从第一行开始，尝试在每一列放置皇后
2. 检查当前位置是否安全（不与已放置的皇后冲突）
3. 如果安全，继续处理下一行
4. 如果所有列都不安全，回溯到上一行
5. 当成功放置8个皇后时，保存当前解

### 性能优化

使用三个布尔数组进行O(1)时间复杂度的冲突检测：
- `_cols[col]`：标记被占用的列
- `_diag1[row - col + 7]`：标记被占用的正斜线（/）
- `_diag2[row + col]`：标记被占用的反斜线（\）

## 编译和运行

### 环境要求

- CMake 3.10 或更高版本
- 支持C++20的编译器（GCC 10+、Clang 10+、MSVC 2019+）

### 编译步骤

```bash
mkdir -p build
cd build
cmake ..
make
```

### 运行程序

```bash
./eight_queens_2206
```

## 示例输出

```
正在求解8皇后问题...

找到 92 个解

以下是前3个解的示例：

Solution 1:
Q . . . . . . .
. . . . Q . . .
. . . . . . . Q
. . . . . Q . .
. . Q . . . . .
. . . . . . Q .
. Q . . . . . .
. . . Q . . . .

Solution 2:
Q . . . . . . .
. . . . . Q . .
. . . . . . . Q
. . Q . . . . .
. . . . . . Q .
. . . Q . . . .
. Q . . . . . .
. . . . Q . . .

Solution 3:
Q . . . . . . .
. . . . . . Q .
. . . Q . . . .
. . . . . Q . .
. . . . . . . Q
. Q . . . . . .
. . . . Q . . .
. . Q . . . . .
```

说明：
- `Q` 表示皇后的位置
- `.` 表示空格

## 项目结构

```
eight_queens_2206/
├── CMakeLists.txt      # CMake构建配置
├── main.cpp            # 主程序入口
├── queen.h             # Queen类头文件
├── queen.cpp           # Queen类实现
├── .clang-format       # 代码格式化配置
└── README.md           # 项目说明文档
```

## 代码结构

### Queen类

**公共方法：**
- `solve()`：求解8皇后问题，返回解的数量
- `print_all_solutions()`：打印所有解
- `print_solution(int index)`：打印指定的解
- `get_solution_count()`：获取解的数量

**私有方法：**
- `backtrack(int row)`：回溯算法核心实现
- `is_safe(int row, int col)`：检查位置是否安全

**数据成员：**
- `_positions`：当前解的皇后位置
- `_solutions`：所有找到的解
- `_cols`、`_diag1`、`_diag2`：冲突检测标记数组

## 技术特点

1. **C++20标准**：使用现代C++特性
2. **[[nodiscard]]属性**：标记重要返回值，防止误用
3. **常量表达式**：使用`constexpr`定义棋盘大小
4. **清晰的代码结构**：职责分明，易于理解和维护
5. **高效的算法**：O(1)冲突检测，快速求解

## 扩展功能

如需查看所有92个解，可以修改`main.cpp`：

```cpp
// 取消注释这行
queen.print_all_solutions();
```

## 作者

Eight Queens Solver - 2206

## 许可证

MIT License
